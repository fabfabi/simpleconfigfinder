{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Config Finder Finds a configuration file (e.g. pyproject.toml) and returns some sub-configuration with only python standard libraries. Note Supported formats: TOML JSON INI YAML (see below) Algorighm starts from the currently executed file (__main__.__file__) Checks if that folder contains the desired configuration file Goes to the parent directory and repeats at 2 Use Case When defining machine learning projects and handling the project configuration by e.g. a pyproject.toml (e.g. with Astral UV or Poetry ) you can utilize the configuration files to define and store important variables. [tool.some_tool] key1 = \"some_value_1\" key2 = \"some_value_2\" [tool.some_tool.default_config] important_key = \"some_value\" [tool.some_tool.special_config] important_key = \"another_value\" Tip Instead of defining global variables in your code or using dotenv , a configuration file such as the pyproject.toml can be used to store configurations. Access works via find_configuration(\"pyproject.toml\", [\"tool\", \"some_tool\", \"default_config\"]) {\"important_key\" : \"some_value\"} This function can also be used to handle credentials. Caution Do not write your credentials into the pyproject.toml and ensure that you do not check your credentials into the source control. Other Readers Other readers can be used e.g. for YAML via PyYAML / PyPI: PyYAML works like this: import yaml from simpleconfigfinder import config_finder config_finder( \"some_file.yaml\", additional_readers={\"yaml\": yaml.safe_load} )","title":"Overview"},{"location":"#config-finder","text":"Finds a configuration file (e.g. pyproject.toml) and returns some sub-configuration with only python standard libraries. Note Supported formats: TOML JSON INI YAML (see below)","title":"Config Finder"},{"location":"#algorighm","text":"starts from the currently executed file (__main__.__file__) Checks if that folder contains the desired configuration file Goes to the parent directory and repeats at 2","title":"Algorighm"},{"location":"#use-case","text":"When defining machine learning projects and handling the project configuration by e.g. a pyproject.toml (e.g. with Astral UV or Poetry ) you can utilize the configuration files to define and store important variables. [tool.some_tool] key1 = \"some_value_1\" key2 = \"some_value_2\" [tool.some_tool.default_config] important_key = \"some_value\" [tool.some_tool.special_config] important_key = \"another_value\" Tip Instead of defining global variables in your code or using dotenv , a configuration file such as the pyproject.toml can be used to store configurations. Access works via find_configuration(\"pyproject.toml\", [\"tool\", \"some_tool\", \"default_config\"]) {\"important_key\" : \"some_value\"} This function can also be used to handle credentials. Caution Do not write your credentials into the pyproject.toml and ensure that you do not check your credentials into the source control.","title":"Use Case"},{"location":"#other-readers","text":"Other readers can be used e.g. for YAML via PyYAML / PyPI: PyYAML works like this: import yaml from simpleconfigfinder import config_finder config_finder( \"some_file.yaml\", additional_readers={\"yaml\": yaml.safe_load} )","title":"Other Readers"},{"location":"configfinder/","text":"simpleconfigfinder This is a small package with utility functions to find and handle configuration files that are stored upstream from the code. configfinder ErrorConfigNotFound Bases: Exception will be raised when the given keys for the sub-configuration do not exist in the configuration file Source code in src\\simpleconfigfinder\\configfinder.py 13 14 15 16 class ErrorConfigNotFound ( Exception ): \"\"\"will be raised when the given keys for the sub-configuration do not exist in the configuration file\"\"\" pass combine_dictionaries combine_dictionaries ( dict_a , dict_b ) combine two dictionaries on a granular level. The entries of dict_a always have priority over entries of dict_b . Caution this function modifies the original dicitionaries. If this matters, use: from copy import deepcopy combine_dictionaries(dict_a, deepcopy(dict_b)) Parameters: dict_a ( Any ) \u2013 Reference dictionary dict_b ( Any ) \u2013 Another dictionary from where the key will be added Returns: Any \u2013 Combined dictionary of both dict_a and dict_b. Values from dict_a have priority over dict_b. If some values are dictionaries, they will be combined recursively. Examples: >>> combine_dictionaries({\"a\" : 1}, {\"b\" : 2}) {'b': 2, 'a': 1} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"c\" : 4}}) {'a': {'c': 3}} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"e\" : 5}}) {'a': {'e': 5, 'c': 3}} >>> some_dictionary = {\"a\" : 1} # to show changes >>> combine_dictionaries({\"b\" : 2}, some_dictionary) {'a': 1, 'b': 2} >>> some_dictionary # ATTENTION: modified {'a': 1, 'b': 2} >>> from copy import deepcopy >>> some_dictionary = {\"a\" : 1} >>> combine_dictionaries({\"b\" : 2}, deepcopy(some_dictionary)) {'a': 1, 'b': 2} >>> some_dictionary {'a': 1} Source code in src\\simpleconfigfinder\\configfinder.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def combine_dictionaries ( dict_a : Any , dict_b : Any ) -> Any : \"\"\"combine two dictionaries on a granular level. The entries of `dict_a` always have priority over entries of `dict_b`. !!! caution this function modifies the original dicitionaries. If this matters, use: from copy import deepcopy combine_dictionaries(dict_a, deepcopy(dict_b)) Args: dict_a: Reference dictionary dict_b: Another dictionary from where the key will be added Returns: Combined dictionary of both dict_a and dict_b. Values from dict_a have priority over dict_b. If some values are dictionaries, they will be combined recursively. <!--note that the blank line behind Example needs to be there. There are two options. Either the examples are rendered properly (with integrated drop-down) Or the Doctests are rendered properly--> Examples: >>> combine_dictionaries({\"a\" : 1}, {\"b\" : 2}) {'b': 2, 'a': 1} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"c\" : 4}}) {'a': {'c': 3}} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"e\" : 5}}) {'a': {'e': 5, 'c': 3}} >>> some_dictionary = {\"a\" : 1} # to show changes >>> combine_dictionaries({\"b\" : 2}, some_dictionary) {'a': 1, 'b': 2} >>> some_dictionary # ATTENTION: modified {'a': 1, 'b': 2} >>> from copy import deepcopy >>> some_dictionary = {\"a\" : 1} >>> combine_dictionaries({\"b\" : 2}, deepcopy(some_dictionary)) {'a': 1, 'b': 2} >>> some_dictionary {'a': 1} \"\"\" def check_instance ( db ): return isinstance ( db , collections . abc . Mapping ) # dict a not a dictionary -> dict_a over-writes dict_b if not check_instance ( dict_a ): return dict_a # dict a not a dictionary -> dict_a over-writes dict_b if not check_instance ( dict_b ): return dict_a # both are dictionaries -> recursively combine for k , v in dict_a . items (): if check_instance ( v ): dict_b [ k ] = combine_dictionaries ( v , dict_b . get ( k , {})) else : dict_b [ k ] = v # add missing keys as they wil not be passed by the loop missing_keys = { k : v for k , v in dict_b . items () if k not in dict_a } dict_b . update ( missing_keys ) return dict_b config_finder config_finder ( config_fname , sub_config_keys = None , raise_error = True , additional_readers = None , strategy = \"__main__\" , ) goes upstream from the currently executed file and finds the file config_fname and returns the sub_config_keys Starts with the directory of the currently executed file ( __main__.__file__ ) and searches upstream. For Jupyter Notebooks, os.path.abspath(\"\") will be returned instead. Examples: When configurations to the pyproject.toml like [tool.some_tool.default_config] some_key = \"some_value\" Then you can get these values via >>> config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"default_config\"]) {'some_key': 'some_value'} Parameters: config_fname ( str | PurePath ) \u2013 The name of the configuration file as toml or json. sub_config_keys ( Optional [ list [ str ]] , default: None ) \u2013 A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error ( bool , default: True ) \u2013 if errors will be raised in case any of the files are not found additional_readers ( Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] , default: None ) \u2013 dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see Other Readers strategy ( str , default: '__main__' ) \u2013 will be passed to find_file to determine the initial file Returns: Dict [ str , Any ] \u2013 \"filtered\" Dictionary, where teh sub_config_keys where already applied. I.e. config[sub_config_keys[0]][sub_config_keys[1]]... Source code in src\\simpleconfigfinder\\configfinder.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def config_finder ( config_fname : str | PurePath , sub_config_keys : Optional [ list [ str ]] = None , raise_error : bool = True , additional_readers : Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] = None , strategy : str = \"__main__\" , ) -> Dict [ str , Any ]: \"\"\"goes upstream from the currently executed file and finds the file `config_fname` and returns the `sub_config_keys` Starts with the directory of the currently executed file (`__main__.__file__`) and searches upstream. For Jupyter Notebooks, `os.path.abspath(\"\")` will be returned instead. Examples: When configurations to the pyproject.toml like [tool.some_tool.default_config] some_key = \"some_value\" Then you can get these values via >>> config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"default_config\"]) {'some_key': 'some_value'} Args: config_fname: The name of the configuration file as toml or json. sub_config_keys: A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error: if errors will be raised in case any of the files are not found additional_readers: dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see [Other Readers](index.md#other-readers) strategy: will be passed to `find_file` to determine the initial file Returns: \"filtered\" Dictionary, where teh sub_config_keys where already applied. I.e. config[sub_config_keys[0]][sub_config_keys[1]]... \"\"\" try : fname = find_file ( config_fname , strategy = strategy ) # type: ignore since list values are handled above except FileNotFoundError as err : if raise_error : raise err else : return {} configuration = config_reader ( fname , additional_readers = additional_readers ) if sub_config_keys is None : return configuration return config_walker ( configuration , sub_config_keys ) config_reader config_reader ( fname , additional_readers = None ) can read toml , json , ini and custom extensions via additional_readers Parameters: fname ( str | PurePath ) \u2013 Name and Path of the configuration file additional_readers ( Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] , default: None ) \u2013 Dictionary with additional readers for non-standard extensions Source code in src\\simpleconfigfinder\\configfinder.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def config_reader ( fname : str | PurePath , additional_readers : Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] = None , ): \"\"\"can read `toml`, `json`, `ini` and custom extensions via additional_readers Args: fname: Name and Path of the configuration file additional_readers: Dictionary with additional readers for non-standard extensions\"\"\" # cut the leading dot extension = Path ( fname ) . suffix [ 1 :] . lower () def ini_reader ( file ) -> Dict : \"\"\"small unitility function to read ini files\"\"\" cfg = ConfigParser () cfg . read ( file ) return configparser_to_dict ( cfg ) reader_dictionary = { \"toml\" : tomllib . load , \"json\" : json . load , \"ini\" : ini_reader } if additional_readers : reader_dictionary . update ( additional_readers ) if extension not in reader_dictionary : raise NotImplementedError ( f \"config finder not implmeneted for ' { extension } '. Use any of ' { reader_dictionary . keys () } '\" ) reader = reader_dictionary [ extension ] with open ( fname , \"rb\" ) as file : return reader ( file ) config_walker config_walker ( configuration_dictionary , sub_config_keys ) goes upstream from the currently executed file and finds the file config_fname and returns the sub_config_keys Parameters: configuration_dictionary ( Dict [ str , Any ] ) \u2013 containing the configuration as dictionary of dictionaries sub_config_keys ( list [ str ] ) \u2013 defines the keys of the branches that are supposed to be returned Example: >>> config_walker({\"a\": {\"b\" : {\"b1\" : 1, \"b2\" : 2}}}, [\"a\", \"b\"]) {'b1': 1, 'b2': 2} Source code in src\\simpleconfigfinder\\configfinder.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def config_walker ( configuration_dictionary : Dict [ str , Any ], sub_config_keys : list [ str ] ) -> Dict [ str , Any ]: \"\"\"goes upstream from the currently executed file and finds the file `config_fname` and returns the `sub_config_keys` Args: configuration_dictionary: containing the configuration as dictionary of dictionaries sub_config_keys: defines the keys of the branches that are supposed to be returned Example: >>> config_walker({\"a\": {\"b\" : {\"b1\" : 1, \"b2\" : 2}}}, [\"a\", \"b\"]) {'b1': 1, 'b2': 2}\"\"\" for i , key in enumerate ( sub_config_keys ): if key in configuration_dictionary : configuration_dictionary = configuration_dictionary [ key ] else : raise ErrorConfigNotFound ( f \"configuration { sub_config_keys [: i + 1 ] } not found\" ) return configuration_dictionary configparser_to_dict configparser_to_dict ( configuration ) converts a configparser element (handling ini files) to a dictionary Example: >>> from configparser import ConfigParser >>> cfg = ConfigParser() >>> cfg.read_dict({ \"a\": {\"a1\": \"1\", \"a2\": \"2\"}}) >>> configparser_to_dict(cfg) {'DEFAULT': {}, 'a': {'a1': '1', 'a2': '2'}} Parameters: configuration ( ConfigParser ) \u2013 configuration object loaded by the configparser Returns: Dict [ str , Any ] \u2013 dictionary of entries Source code in src\\simpleconfigfinder\\configfinder.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def configparser_to_dict ( configuration : configparser . ConfigParser ) -> Dict [ str , Any ]: \"\"\"converts a configparser element (handling ini files) to a dictionary Example: >>> from configparser import ConfigParser >>> cfg = ConfigParser() >>> cfg.read_dict({ \"a\": {\"a1\": \"1\", \"a2\": \"2\"}}) >>> configparser_to_dict(cfg) {'DEFAULT': {}, 'a': {'a1': '1', 'a2': '2'}} Args: configuration: configuration object loaded by the configparser Returns: dictionary of entries\"\"\" return { key : value if type ( value ) is not configparser . SectionProxy else { k : v for k , v in value . items ()} for key , value in configuration . items () } find_file find_file ( config_fname , strategy = '__main__' ) finds the configuration file by checking every parent directory from the starting file (as determined by get_starting_file) Strategy main : Starts with the directory of the currently executed file ( __main__.__file__ ) and searches upstream. For Jupyter Notebooks, os.path.abspath(\"\") will be returned instead. Strategy cwd: starts with os.cwd() Parameters: config_fname ( str | PurePath ) \u2013 the name of the configuration file strategy ( str , default: '__main__' ) \u2013 can bei either main or cwd Source code in src\\simpleconfigfinder\\configfinder.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def find_file ( config_fname : str | PurePath , strategy : str = \"__main__\" ) -> PurePath : \"\"\"finds the configuration file by checking every parent directory from the starting file (as determined by get_starting_file) Strategy __main__: Starts with the directory of the currently executed file (`__main__.__file__`) and searches upstream. For Jupyter Notebooks, `os.path.abspath(\"\")` will be returned instead. Strategy cwd: starts with os.cwd() Args: config_fname: the name of the configuration file strategy: can bei either __main__ or cwd\"\"\" directory = get_starting_file ( strategy ) while directory . parent != directory : if ( directory / config_fname ) . exists (): return directory / config_fname # go one up directory = directory . parent raise FileNotFoundError ( f \"' { config_fname } ' was not found\" ) get_starting_file get_starting_file ( strategy = '__main__' ) determines the starting file for the identification of the configuration file Parameters: strategy ( str , default: '__main__' ) \u2013 the strategy for how to go up from the current path Source code in src\\simpleconfigfinder\\configfinder.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def get_starting_file ( strategy : str = \"__main__\" ) -> Path : \"\"\"determines the starting file for the identification of the configuration file Args: strategy: the strategy for how to go up from the current path\"\"\" if strategy == \"__main__\" : try : directory = Path ( __main__ . __file__ ) . parent except AttributeError : # above version does not work for *.ipynb directory = Path ( os . path . abspath ( \"\" )) elif strategy == \"cwd\" : directory = Path ( os . getcwd ()) else : raise ValueError ( f \"unknown strategy { strategy } \" ) return directory multi_config_finder multi_config_finder ( config_fname , sub_config_keys = None , raise_error = True , additional_readers = None , strategy = \"__main__\" , ) goes upstream from the currently executed file and finds the file config_fname and returns the sub_config_keys Starts with the directory of the currently executed file ( __main__.__file__ ) and searches upstream. In case there are multiple configuration files provided and keys are in multiple of them, the first occurence will be returned. This function first combines all files and afterwards applies the sub_config_keys Parameters: config_fname ( list [ str ] | list [ PurePath ] ) \u2013 List of configuration files. The output will be combined. In case of double definition, input from earlier mentioned files will not be over-written (but additional keys added). sub_config_keys ( Optional [ list [ str ]] , default: None ) \u2013 A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error ( bool , default: True ) \u2013 if errors will be raised in case any of the files are not found additional_readers ( Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] , default: None ) \u2013 dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see Other Readers strategy ( str , default: '__main__' ) \u2013 will be passed to find_file Source code in src\\simpleconfigfinder\\configfinder.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def multi_config_finder ( config_fname : list [ str ] | list [ PurePath ], sub_config_keys : Optional [ list [ str ]] = None , raise_error : bool = True , additional_readers : Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] = None , strategy : str = \"__main__\" , ) -> Dict [ str , Any ]: \"\"\"goes upstream from the currently executed file and finds the file `config_fname` and returns the `sub_config_keys` Starts with the directory of the currently executed file (`__main__.__file__`) and searches upstream. In case there are multiple configuration files provided and keys are in multiple of them, the first occurence will be returned. This function first combines all files and afterwards applies the sub_config_keys Args: config_fname: List of configuration files. The output will be combined. In case of double definition, input from earlier mentioned files will not be over-written (but additional keys added). sub_config_keys: A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error: if errors will be raised in case any of the files are not found additional_readers: dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see [Other Readers](index.md#other-readers) strategy: will be passed to `find_file` \"\"\" configs_all = [ config_finder ( config_fname = file , raise_error = raise_error , additional_readers = additional_readers , strategy = strategy , ) for file in config_fname ] configuration = configs_all . pop () for cfg in configs_all : configuration = combine_dictionaries ( configuration , cfg ) if sub_config_keys is None : return configuration return config_walker ( configuration , sub_config_keys )","title":"API Reference"},{"location":"configfinder/#simpleconfigfinder_1","text":"This is a small package with utility functions to find and handle configuration files that are stored upstream from the code.","title":"simpleconfigfinder"},{"location":"configfinder/#simpleconfigfinder.configfinder","text":"","title":"configfinder"},{"location":"configfinder/#simpleconfigfinder.configfinder.ErrorConfigNotFound","text":"Bases: Exception will be raised when the given keys for the sub-configuration do not exist in the configuration file Source code in src\\simpleconfigfinder\\configfinder.py 13 14 15 16 class ErrorConfigNotFound ( Exception ): \"\"\"will be raised when the given keys for the sub-configuration do not exist in the configuration file\"\"\" pass","title":"ErrorConfigNotFound"},{"location":"configfinder/#simpleconfigfinder.configfinder.combine_dictionaries","text":"combine_dictionaries ( dict_a , dict_b ) combine two dictionaries on a granular level. The entries of dict_a always have priority over entries of dict_b . Caution this function modifies the original dicitionaries. If this matters, use: from copy import deepcopy combine_dictionaries(dict_a, deepcopy(dict_b)) Parameters: dict_a ( Any ) \u2013 Reference dictionary dict_b ( Any ) \u2013 Another dictionary from where the key will be added Returns: Any \u2013 Combined dictionary of both dict_a and dict_b. Values from dict_a have priority over dict_b. If some values are dictionaries, they will be combined recursively. Examples: >>> combine_dictionaries({\"a\" : 1}, {\"b\" : 2}) {'b': 2, 'a': 1} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"c\" : 4}}) {'a': {'c': 3}} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"e\" : 5}}) {'a': {'e': 5, 'c': 3}} >>> some_dictionary = {\"a\" : 1} # to show changes >>> combine_dictionaries({\"b\" : 2}, some_dictionary) {'a': 1, 'b': 2} >>> some_dictionary # ATTENTION: modified {'a': 1, 'b': 2} >>> from copy import deepcopy >>> some_dictionary = {\"a\" : 1} >>> combine_dictionaries({\"b\" : 2}, deepcopy(some_dictionary)) {'a': 1, 'b': 2} >>> some_dictionary {'a': 1} Source code in src\\simpleconfigfinder\\configfinder.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def combine_dictionaries ( dict_a : Any , dict_b : Any ) -> Any : \"\"\"combine two dictionaries on a granular level. The entries of `dict_a` always have priority over entries of `dict_b`. !!! caution this function modifies the original dicitionaries. If this matters, use: from copy import deepcopy combine_dictionaries(dict_a, deepcopy(dict_b)) Args: dict_a: Reference dictionary dict_b: Another dictionary from where the key will be added Returns: Combined dictionary of both dict_a and dict_b. Values from dict_a have priority over dict_b. If some values are dictionaries, they will be combined recursively. <!--note that the blank line behind Example needs to be there. There are two options. Either the examples are rendered properly (with integrated drop-down) Or the Doctests are rendered properly--> Examples: >>> combine_dictionaries({\"a\" : 1}, {\"b\" : 2}) {'b': 2, 'a': 1} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"c\" : 4}}) {'a': {'c': 3}} >>> combine_dictionaries({\"a\" : {\"c\" : 3}}, {\"a\" : {\"e\" : 5}}) {'a': {'e': 5, 'c': 3}} >>> some_dictionary = {\"a\" : 1} # to show changes >>> combine_dictionaries({\"b\" : 2}, some_dictionary) {'a': 1, 'b': 2} >>> some_dictionary # ATTENTION: modified {'a': 1, 'b': 2} >>> from copy import deepcopy >>> some_dictionary = {\"a\" : 1} >>> combine_dictionaries({\"b\" : 2}, deepcopy(some_dictionary)) {'a': 1, 'b': 2} >>> some_dictionary {'a': 1} \"\"\" def check_instance ( db ): return isinstance ( db , collections . abc . Mapping ) # dict a not a dictionary -> dict_a over-writes dict_b if not check_instance ( dict_a ): return dict_a # dict a not a dictionary -> dict_a over-writes dict_b if not check_instance ( dict_b ): return dict_a # both are dictionaries -> recursively combine for k , v in dict_a . items (): if check_instance ( v ): dict_b [ k ] = combine_dictionaries ( v , dict_b . get ( k , {})) else : dict_b [ k ] = v # add missing keys as they wil not be passed by the loop missing_keys = { k : v for k , v in dict_b . items () if k not in dict_a } dict_b . update ( missing_keys ) return dict_b","title":"combine_dictionaries"},{"location":"configfinder/#simpleconfigfinder.configfinder.config_finder","text":"config_finder ( config_fname , sub_config_keys = None , raise_error = True , additional_readers = None , strategy = \"__main__\" , ) goes upstream from the currently executed file and finds the file config_fname and returns the sub_config_keys Starts with the directory of the currently executed file ( __main__.__file__ ) and searches upstream. For Jupyter Notebooks, os.path.abspath(\"\") will be returned instead. Examples: When configurations to the pyproject.toml like [tool.some_tool.default_config] some_key = \"some_value\" Then you can get these values via >>> config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"default_config\"]) {'some_key': 'some_value'} Parameters: config_fname ( str | PurePath ) \u2013 The name of the configuration file as toml or json. sub_config_keys ( Optional [ list [ str ]] , default: None ) \u2013 A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error ( bool , default: True ) \u2013 if errors will be raised in case any of the files are not found additional_readers ( Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] , default: None ) \u2013 dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see Other Readers strategy ( str , default: '__main__' ) \u2013 will be passed to find_file to determine the initial file Returns: Dict [ str , Any ] \u2013 \"filtered\" Dictionary, where teh sub_config_keys where already applied. I.e. config[sub_config_keys[0]][sub_config_keys[1]]... Source code in src\\simpleconfigfinder\\configfinder.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def config_finder ( config_fname : str | PurePath , sub_config_keys : Optional [ list [ str ]] = None , raise_error : bool = True , additional_readers : Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] = None , strategy : str = \"__main__\" , ) -> Dict [ str , Any ]: \"\"\"goes upstream from the currently executed file and finds the file `config_fname` and returns the `sub_config_keys` Starts with the directory of the currently executed file (`__main__.__file__`) and searches upstream. For Jupyter Notebooks, `os.path.abspath(\"\")` will be returned instead. Examples: When configurations to the pyproject.toml like [tool.some_tool.default_config] some_key = \"some_value\" Then you can get these values via >>> config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"default_config\"]) {'some_key': 'some_value'} Args: config_fname: The name of the configuration file as toml or json. sub_config_keys: A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error: if errors will be raised in case any of the files are not found additional_readers: dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see [Other Readers](index.md#other-readers) strategy: will be passed to `find_file` to determine the initial file Returns: \"filtered\" Dictionary, where teh sub_config_keys where already applied. I.e. config[sub_config_keys[0]][sub_config_keys[1]]... \"\"\" try : fname = find_file ( config_fname , strategy = strategy ) # type: ignore since list values are handled above except FileNotFoundError as err : if raise_error : raise err else : return {} configuration = config_reader ( fname , additional_readers = additional_readers ) if sub_config_keys is None : return configuration return config_walker ( configuration , sub_config_keys )","title":"config_finder"},{"location":"configfinder/#simpleconfigfinder.configfinder.config_reader","text":"config_reader ( fname , additional_readers = None ) can read toml , json , ini and custom extensions via additional_readers Parameters: fname ( str | PurePath ) \u2013 Name and Path of the configuration file additional_readers ( Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] , default: None ) \u2013 Dictionary with additional readers for non-standard extensions Source code in src\\simpleconfigfinder\\configfinder.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 def config_reader ( fname : str | PurePath , additional_readers : Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] = None , ): \"\"\"can read `toml`, `json`, `ini` and custom extensions via additional_readers Args: fname: Name and Path of the configuration file additional_readers: Dictionary with additional readers for non-standard extensions\"\"\" # cut the leading dot extension = Path ( fname ) . suffix [ 1 :] . lower () def ini_reader ( file ) -> Dict : \"\"\"small unitility function to read ini files\"\"\" cfg = ConfigParser () cfg . read ( file ) return configparser_to_dict ( cfg ) reader_dictionary = { \"toml\" : tomllib . load , \"json\" : json . load , \"ini\" : ini_reader } if additional_readers : reader_dictionary . update ( additional_readers ) if extension not in reader_dictionary : raise NotImplementedError ( f \"config finder not implmeneted for ' { extension } '. Use any of ' { reader_dictionary . keys () } '\" ) reader = reader_dictionary [ extension ] with open ( fname , \"rb\" ) as file : return reader ( file )","title":"config_reader"},{"location":"configfinder/#simpleconfigfinder.configfinder.config_walker","text":"config_walker ( configuration_dictionary , sub_config_keys ) goes upstream from the currently executed file and finds the file config_fname and returns the sub_config_keys Parameters: configuration_dictionary ( Dict [ str , Any ] ) \u2013 containing the configuration as dictionary of dictionaries sub_config_keys ( list [ str ] ) \u2013 defines the keys of the branches that are supposed to be returned Example: >>> config_walker({\"a\": {\"b\" : {\"b1\" : 1, \"b2\" : 2}}}, [\"a\", \"b\"]) {'b1': 1, 'b2': 2} Source code in src\\simpleconfigfinder\\configfinder.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def config_walker ( configuration_dictionary : Dict [ str , Any ], sub_config_keys : list [ str ] ) -> Dict [ str , Any ]: \"\"\"goes upstream from the currently executed file and finds the file `config_fname` and returns the `sub_config_keys` Args: configuration_dictionary: containing the configuration as dictionary of dictionaries sub_config_keys: defines the keys of the branches that are supposed to be returned Example: >>> config_walker({\"a\": {\"b\" : {\"b1\" : 1, \"b2\" : 2}}}, [\"a\", \"b\"]) {'b1': 1, 'b2': 2}\"\"\" for i , key in enumerate ( sub_config_keys ): if key in configuration_dictionary : configuration_dictionary = configuration_dictionary [ key ] else : raise ErrorConfigNotFound ( f \"configuration { sub_config_keys [: i + 1 ] } not found\" ) return configuration_dictionary","title":"config_walker"},{"location":"configfinder/#simpleconfigfinder.configfinder.configparser_to_dict","text":"configparser_to_dict ( configuration ) converts a configparser element (handling ini files) to a dictionary Example: >>> from configparser import ConfigParser >>> cfg = ConfigParser() >>> cfg.read_dict({ \"a\": {\"a1\": \"1\", \"a2\": \"2\"}}) >>> configparser_to_dict(cfg) {'DEFAULT': {}, 'a': {'a1': '1', 'a2': '2'}} Parameters: configuration ( ConfigParser ) \u2013 configuration object loaded by the configparser Returns: Dict [ str , Any ] \u2013 dictionary of entries Source code in src\\simpleconfigfinder\\configfinder.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def configparser_to_dict ( configuration : configparser . ConfigParser ) -> Dict [ str , Any ]: \"\"\"converts a configparser element (handling ini files) to a dictionary Example: >>> from configparser import ConfigParser >>> cfg = ConfigParser() >>> cfg.read_dict({ \"a\": {\"a1\": \"1\", \"a2\": \"2\"}}) >>> configparser_to_dict(cfg) {'DEFAULT': {}, 'a': {'a1': '1', 'a2': '2'}} Args: configuration: configuration object loaded by the configparser Returns: dictionary of entries\"\"\" return { key : value if type ( value ) is not configparser . SectionProxy else { k : v for k , v in value . items ()} for key , value in configuration . items () }","title":"configparser_to_dict"},{"location":"configfinder/#simpleconfigfinder.configfinder.find_file","text":"find_file ( config_fname , strategy = '__main__' ) finds the configuration file by checking every parent directory from the starting file (as determined by get_starting_file) Strategy main : Starts with the directory of the currently executed file ( __main__.__file__ ) and searches upstream. For Jupyter Notebooks, os.path.abspath(\"\") will be returned instead. Strategy cwd: starts with os.cwd() Parameters: config_fname ( str | PurePath ) \u2013 the name of the configuration file strategy ( str , default: '__main__' ) \u2013 can bei either main or cwd Source code in src\\simpleconfigfinder\\configfinder.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def find_file ( config_fname : str | PurePath , strategy : str = \"__main__\" ) -> PurePath : \"\"\"finds the configuration file by checking every parent directory from the starting file (as determined by get_starting_file) Strategy __main__: Starts with the directory of the currently executed file (`__main__.__file__`) and searches upstream. For Jupyter Notebooks, `os.path.abspath(\"\")` will be returned instead. Strategy cwd: starts with os.cwd() Args: config_fname: the name of the configuration file strategy: can bei either __main__ or cwd\"\"\" directory = get_starting_file ( strategy ) while directory . parent != directory : if ( directory / config_fname ) . exists (): return directory / config_fname # go one up directory = directory . parent raise FileNotFoundError ( f \"' { config_fname } ' was not found\" )","title":"find_file"},{"location":"configfinder/#simpleconfigfinder.configfinder.get_starting_file","text":"get_starting_file ( strategy = '__main__' ) determines the starting file for the identification of the configuration file Parameters: strategy ( str , default: '__main__' ) \u2013 the strategy for how to go up from the current path Source code in src\\simpleconfigfinder\\configfinder.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def get_starting_file ( strategy : str = \"__main__\" ) -> Path : \"\"\"determines the starting file for the identification of the configuration file Args: strategy: the strategy for how to go up from the current path\"\"\" if strategy == \"__main__\" : try : directory = Path ( __main__ . __file__ ) . parent except AttributeError : # above version does not work for *.ipynb directory = Path ( os . path . abspath ( \"\" )) elif strategy == \"cwd\" : directory = Path ( os . getcwd ()) else : raise ValueError ( f \"unknown strategy { strategy } \" ) return directory","title":"get_starting_file"},{"location":"configfinder/#simpleconfigfinder.configfinder.multi_config_finder","text":"multi_config_finder ( config_fname , sub_config_keys = None , raise_error = True , additional_readers = None , strategy = \"__main__\" , ) goes upstream from the currently executed file and finds the file config_fname and returns the sub_config_keys Starts with the directory of the currently executed file ( __main__.__file__ ) and searches upstream. In case there are multiple configuration files provided and keys are in multiple of them, the first occurence will be returned. This function first combines all files and afterwards applies the sub_config_keys Parameters: config_fname ( list [ str ] | list [ PurePath ] ) \u2013 List of configuration files. The output will be combined. In case of double definition, input from earlier mentioned files will not be over-written (but additional keys added). sub_config_keys ( Optional [ list [ str ]] , default: None ) \u2013 A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error ( bool , default: True ) \u2013 if errors will be raised in case any of the files are not found additional_readers ( Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] , default: None ) \u2013 dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see Other Readers strategy ( str , default: '__main__' ) \u2013 will be passed to find_file Source code in src\\simpleconfigfinder\\configfinder.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def multi_config_finder ( config_fname : list [ str ] | list [ PurePath ], sub_config_keys : Optional [ list [ str ]] = None , raise_error : bool = True , additional_readers : Optional [ Dict [ str , Callable [[ Any ], Dict [ str , Any ]]]] = None , strategy : str = \"__main__\" , ) -> Dict [ str , Any ]: \"\"\"goes upstream from the currently executed file and finds the file `config_fname` and returns the `sub_config_keys` Starts with the directory of the currently executed file (`__main__.__file__`) and searches upstream. In case there are multiple configuration files provided and keys are in multiple of them, the first occurence will be returned. This function first combines all files and afterwards applies the sub_config_keys Args: config_fname: List of configuration files. The output will be combined. In case of double definition, input from earlier mentioned files will not be over-written (but additional keys added). sub_config_keys: A list of the keys to identify the sub-configuration. returns the full config if nothing is provided. raise_error: if errors will be raised in case any of the files are not found additional_readers: dictionary to define for file extensions which readers will be used (e.g. for yaml via {\"yaml\": yaml.safe_load}). In general this works for any function that can take a file name as string or PurePath and return a dictionary. For a code example see [Other Readers](index.md#other-readers) strategy: will be passed to `find_file` \"\"\" configs_all = [ config_finder ( config_fname = file , raise_error = raise_error , additional_readers = additional_readers , strategy = strategy , ) for file in config_fname ] configuration = configs_all . pop () for cfg in configs_all : configuration = combine_dictionaries ( configuration , cfg ) if sub_config_keys is None : return configuration return config_walker ( configuration , sub_config_keys )","title":"multi_config_finder"},{"location":"testing/","text":"Testing Testing frameworks like pytest create a test environment that impacts functionalities of the configfinder. Especially when trying to read from pyproject.toml . Here are some easy ways how to create some fixtures via a monkey patch . from pathlib import Path from unittest.mock import patch import pytest from simpleconfigfinder import ConfigNotFound, config_finder Caution If you're just calling the config_finder from a pytest environment this will raise the ConfigNotFound Error. def test_direct_call(): config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"key1\"]) == \"some_value_1\" This requires the creation of a fixture . @pytest.fixture(scope=\"function\") def fixture_starting_file(): with patch( \"simpleconfigfinder.configfinder.get_starting_file\", return_value=Path(__file__), ): yield And now also the test environment will correctly read the values from the pyproject.toml. def test_config_finder(fixture_starting_file): assert ( config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"key1\"]) == \"some_value_1\" ) Going one step further, you can also create a fixture that will always return custom_config for the testing environment. @pytest.fixture(scope=\"function\") def fixture_test_config(): custom_config = {\"tool\": {\"some_tool\": {\"key1\": \"different_value_1\"}}} with patch( \"simpleconfigfinder.configfinder.config_reader\", return_value = custom_config, ): yield def test_mock(fixture_test_config): assert ( config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"key1\"]) == \"different_value_1\" )","title":"Fixtures for Testing"},{"location":"testing/#testing","text":"Testing frameworks like pytest create a test environment that impacts functionalities of the configfinder. Especially when trying to read from pyproject.toml . Here are some easy ways how to create some fixtures via a monkey patch . from pathlib import Path from unittest.mock import patch import pytest from simpleconfigfinder import ConfigNotFound, config_finder Caution If you're just calling the config_finder from a pytest environment this will raise the ConfigNotFound Error. def test_direct_call(): config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"key1\"]) == \"some_value_1\" This requires the creation of a fixture . @pytest.fixture(scope=\"function\") def fixture_starting_file(): with patch( \"simpleconfigfinder.configfinder.get_starting_file\", return_value=Path(__file__), ): yield And now also the test environment will correctly read the values from the pyproject.toml. def test_config_finder(fixture_starting_file): assert ( config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"key1\"]) == \"some_value_1\" ) Going one step further, you can also create a fixture that will always return custom_config for the testing environment. @pytest.fixture(scope=\"function\") def fixture_test_config(): custom_config = {\"tool\": {\"some_tool\": {\"key1\": \"different_value_1\"}}} with patch( \"simpleconfigfinder.configfinder.config_reader\", return_value = custom_config, ): yield def test_mock(fixture_test_config): assert ( config_finder(\"pyproject.toml\", [\"tool\", \"some_tool\", \"key1\"]) == \"different_value_1\" )","title":"Testing"}]}